% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DBR_fun.R
\name{kernel.DBR}
\alias{kernel.DBR}
\alias{kernel.DBR.crit}
\alias{kernel.DBR.fast}
\title{Kernel functions for DBR}
\usage{
kernel.DBR.crit(msg = "", stepf, pv.numer, lambda, alpha, sorted.pv,
  bigMem = FALSE, verbose = TRUE)

kernel.DBR.fast(msg = "", stepf, pv.numer, lambda, bigMem = FALSE,
  verbose = TRUE)
}
\arguments{
\item{msg}{a character string to be displayed if \code{verbose=TRUE}.}

\item{stepf}{a list of the CDFs under the null hypothesis of each p-value.}

\item{pv.numer}{a numeric vector. Contains all values of the p-values supports if we search for the critical constants. If not, contains only the observed p-values. Must be in increasing order.}

\item{lambda}{a number strictly between 0 and 1.}

\item{alpha}{the target FDR level, a number strictly between 0 and 1.}

\item{sorted.pv}{a vector of observed p-values, in increasing order.}

\item{bigMem}{a boolean. If \code{TRUE}, the code uses matrixes and functions of the apply family as far as possible (faster for small number of hypotheses and support size, but slower otherwise due to memory management overhead). If \code{FALSE}, computations are done with \code{for} loops and chunks to conserve memory.}

\item{verbose}{a boolean indicating if \code{msg} must be printed. Used when \code{bigMem=TRUE}, to print messages informing if in-memory computation was successful or if loops and chunks were used as fallback.}
}
\value{
For \code{kernel.DBR.crit}, 
a list which elements are:
\item{crit.consts}{critical constants}
\item{pval.transf}{transformed p-values}
\item{m.lambda}{last index of observed p-values such that max_i F_i(p) <= lambda,
this needs to be passed to \code{\link{DBR}} to compute adjusted p-values).}

For \code{kernel.DBR.fast},
a vector of transformed p-values.
}
\description{
Kernel functions that transform 
observed p-values or their support according to [DBR-lambda].
The output is used by \code{\link{DBR}}.
Additionally, \code{kernel.DBR.crit} computes and returns
the critical constants.
The end user should not use them.
}
\details{
When computing critical constants,
that is, when using \code{kernel.DBR.crit}, we still need
to get transformed p-values to compute
the adjusted p-values. Also, note that here the critical constants are computed by
the kernel function and not by the principal
function \code{\link{DBR}}, contrary to what happens
with \code{\link{DBH}}. This is why \code{sorted.pv} is needed.

This version: 2018-02-20.
}
\examples{
data(amnesia)

#We only keep the first 100 lines to keep the computations fast.
amnesia<-amnesia[1:100,]

#Construction of the p-values and their support
amnesia.formatted <- fisher.pvalues.support(amnesia)
raw.pvalues <- amnesia.formatted$raw
pCDFlist <- amnesia.formatted$support

m <- length(raw.pvalues)
alpha <- 0.05
lambda <- 0.05

#Compute the step functions from the supports
stepf <- build.stepfuns(pCDFlist)

#If not searching for critical constants, we use only the observed p-values
sorted.pvals <- sort(raw.pvalues)
y <- kernel.DBR.fast("", stepf, sorted.pvals, lambda)

#If searching for critical constants, we use (almost) the complete support
pv.list.all <- unique(sort(as.numeric(unlist(pCDFlist))))
# apply the shortcut drawn from Corollary 3, that is
# c.1 >= the effective critical value associated to min((1 - lambda) * alpha/m , lambda)
pv.list<-short.eff(pv.list.all, min((1 - lambda) * alpha/m , lambda) )
# then re-add the observed p-values (needed to compute the adjusted p-values),
# because we may have removed some of them the shortcut
pv.list <- sort(unique(c(pv.list, sorted.pvals)))
# compute transformed support
y <- kernel.DBR.crit("", stepf, pv.list, lambda, alpha, sorted.pvals)
crit.constants <- y$crit.consts
transformed.pvalues <- y$pval.transf
last.index <- y$m.lambda

}
\seealso{
\code{\link{DBR}}, \code{\link{DiscreteFDR}},
\code{\link{kernel.DBH}}, \code{\link{DBH}}
}
